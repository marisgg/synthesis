// network unitization example with partially observable channels based on:
// L. Yang, S. Murugesan and J. Zhang
// Real-Kime Scheduling over Markovian Channels: When Partial Observability Meets Hard Deadlines
// IEEE Global Telecommunications Conference (GLOBECOM'11), pages 1-5, 2011

pomdp

observable "clk" = clk;
//observable "slot" = slot;
//observable "period" = period;
observable "packet1" = packet1;
observable "packet2" = packet2;

hole int SLOTS in {2..8};
hole int PERIODS in {6..10};

formula last_slot = slot=SLOTS-1;
formula last_period = period=PERIODS-1;
formula end = last_slot & last_period;

formula done = clk=-1;
label "done" = done;


// channel of user 1
const double p1 = 0.8; // prob remain on
const double r1 = 0.2; // prob move from off to on
// channel of user 2
const double p2 = 0.6; // prob remain on
const double r2 = 0.4; // prob move from off to on

hole int chan1_init in {0..1};
hole int chan2_init in {0..1};

formula clk_next = mod(clk+1,4);

module clk
    clk : [-1..3] init 0;

    [slot] clk=0 & !end -> (clk'=clk_next);
    [slot] clk=0 &  end -> (clk'=-1);

    [idle]  clk=1 -> (clk'=clk_next);
    [send1] clk=1 -> (clk'=clk_next);
    [send2] clk=1 -> (clk'=clk_next);

    [newslot]   clk=2 -> (clk'=clk_next);
    [newperiod] clk=3 -> (clk'=clk_next);
endmodule

module slot
    slot : [0..SLOTS_MAX-1] init 0;
    [newslot] true -> (slot'=mod(slot+1,SLOTS));
endmodule

module period
    period : [0..PERIODS_MAX-1] init 0;
    [newperiod] !last_slot -> true;
    [newperiod]  last_slot -> (period'=mod(period+1,PERIODS));
endmodule



module channel1
    chan1 : [0..1]; // channel status (down/up)

    // initialise
    [slot] period=0 & slot=0 -> (chan1'=chan1_init);

    [slot] !(period=0 & slot=0) & chan1=0 -> 1-r1 : (chan1'=0) + r1 : (chan1'=1);
    [slot] !(period=0 & slot=0) & chan1=1 -> 1-p1 : (chan1'=0) + p1 : (chan1'=1);
endmodule

module channel2=channel1[chan1=chan2,chan1_init=chan2_init,p1=p2,r1=r2] endmodule


module packet1
    packet1 : [0..1]; // packet to send in current period

    // new period, new packet
    [slot] slot=0 -> (packet1'=1);
    [slot] slot>0 -> true;

    [send1] packet1=1 & chan1=0 -> true;
    [send1] packet1=1 & chan1=1 -> (packet1'=0);
endmodule

module packet2=packet1[packet1=packet2,send1=send2,chan1=chan2] endmodule


rewards "packets_sent"
    [send1] packet1=1 & chan1=1 : 1;
    [send2] packet2=1 & chan2=1 : 1;
endrewards
